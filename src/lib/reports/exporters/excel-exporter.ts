/**
 * Excelエクスポーター
 */

import type {
  ReportTemplate,
  ReportSection,
  GeneratedReport,
} from '../core/types.js';

export interface ExcelExporterOptions {
  includeRawData?: boolean;
  autoFilter?: boolean;
  freezePanes?: boolean;
  conditionalFormatting?: Array<{
    range: string;
    type: 'dataBar' | 'colorScale' | 'iconSet';
    rules: any;
  }>;
  chartSheets?: boolean;
}

export class ExcelExporter {
  /**
   * Excelへのエクスポート
   */
  async export(
    template: ReportTemplate,
    sections: ReportSection[],
    data: any,
    options?: ExcelExporterOptions
  ): Promise<Buffer> {
    // 実際の実装では、ExcelJSなどのライブラリを使用
    const workbook = this.createWorkbook(template, data);

    // サマリーシートの作成
    this.createSummarySheet(workbook, template, sections, data);

    // セクション別シートの作成
    for (const section of sections) {
      if (section.type === 'table' || section.type === 'metrics') {
        this.createDataSheet(workbook, section, template);
      }
    }

    // チャートシートの作成
    if (options?.chartSheets) {
      this.createChartSheets(workbook, sections, template);
    }

    // 生データシートの作成
    if (options?.includeRawData) {
      this.createRawDataSheet(workbook, data);
    }

    // Buffer.from は実際のExcelバイナリデータに置き換える
    return Buffer.from(JSON.stringify(workbook), 'utf-8');
  }

  /**
   * ワークブックの作成
   */
  private createWorkbook(template: ReportTemplate, data: any): any {
    return {
      properties: {
        title: data.title,
        subject: template.description,
        author: data.metadata.generatedBy,
        created: new Date(),
      },
      sheets: [],
      styles: this.createStyles(template),
    };
  }

  /**
   * スタイルの作成
   */
  private createStyles(template: ReportTemplate): any {
    return {
      header: {
        font: {
          name: template.styling.fonts.primary,
          size: template.styling.fonts.sizes.large,
          bold: true,
          color: { argb: this.colorToARGB(template.styling.colors.primary) },
        },
        fill: {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFFFFFFF' },
        },
        alignment: {
          horizontal: 'center',
          vertical: 'middle',
        },
      },
      subheader: {
        font: {
          name: template.styling.fonts.primary,
          size: template.styling.fonts.sizes.medium,
          bold: true,
          color: { argb: this.colorToARGB(template.styling.colors.text) },
        },
      },
      data: {
        font: {
          name: template.styling.fonts.primary,
          size: template.styling.fonts.sizes.small,
          color: { argb: this.colorToARGB(template.styling.colors.text) },
        },
        alignment: {
          horizontal: 'left',
          vertical: 'middle',
        },
      },
    };
  }

  /**
   * サマリーシートの作成
   */
  private createSummarySheet(
    workbook: any,
    template: ReportTemplate,
    sections: ReportSection[],
    data: any
  ): void {
    const sheet = {
      name: 'Summary',
      data: [],
      merges: [],
      styles: [],
    };

    // タイトル
    sheet.data.push([data.title]);
    sheet.merges.push({ start: 'A1', end: 'F1' });
    sheet.styles.push({ cell: 'A1', style: 'header' });

    // サブタイトル
    if (data.subtitle) {
      sheet.data.push([data.subtitle]);
      sheet.merges.push({ start: 'A2', end: 'F2' });
      sheet.styles.push({ cell: 'A2', style: 'subheader' });
    }

    // メタデータ
    sheet.data.push([]);
    sheet.data.push(['Generated:', data.metadata.generated]);
    sheet.data.push(['Generated By:', data.metadata.generatedBy]);
    sheet.data.push(['Language:', data.metadata.language]);
    sheet.data.push(['Region:', data.metadata.region]);

    // サマリー情報
    if (data.summary) {
      sheet.data.push([]);
      sheet.data.push(['Summary']);
      sheet.styles.push({
        cell: `A${sheet.data.length}`,
        style: 'subheader',
      });

      sheet.data.push(['Total Items:', data.summary.totalItems]);

      if (data.summary.highlights.length > 0) {
        sheet.data.push([]);
        sheet.data.push(['Highlights:']);
        data.summary.highlights.forEach((highlight: string) => {
          sheet.data.push(['', highlight]);
        });
      }

      if (data.summary.recommendations.length > 0) {
        sheet.data.push([]);
        sheet.data.push(['Recommendations:']);
        data.summary.recommendations.forEach((rec: string, index: number) => {
          sheet.data.push([`${index + 1}.`, rec]);
        });
      }
    }

    workbook.sheets.push(sheet);
  }

  /**
   * データシートの作成
   */
  private createDataSheet(
    workbook: any,
    section: ReportSection,
    template: ReportTemplate
  ): void {
    const sheet = {
      name: this.sanitizeSheetName(section.title),
      data: [],
      styles: [],
      autoFilter: false,
      freezePanes: { row: 2, column: 0 },
    };

    if (section.type === 'table') {
      // ヘッダー行
      const headers = section.content.columns.map((col: any) => col.label);
      sheet.data.push(headers);

      // ヘッダーのスタイル
      headers.forEach((_: any, index: number) => {
        const cell = this.getColumnLetter(index) + '1';
        sheet.styles.push({ cell, style: 'header' });
      });

      // データ行
      section.content.rows.forEach((row: any) => {
        const rowData = section.content.columns.map(
          (col: any) => row[col.key] || ''
        );
        sheet.data.push(rowData);
      });

      sheet.autoFilter = true;
    } else if (section.type === 'metrics') {
      // メトリクスの場合
      sheet.data.push(['Metric', 'Value']);
      sheet.styles.push({ cell: 'A1', style: 'header' });
      sheet.styles.push({ cell: 'B1', style: 'header' });

      section.content.forEach((metric: any) => {
        sheet.data.push([metric.label, metric.value]);
      });
    }

    workbook.sheets.push(sheet);
  }

  /**
   * チャートシートの作成
   */
  private createChartSheets(
    workbook: any,
    sections: ReportSection[],
    template: ReportTemplate
  ): void {
    const chartSections = sections.filter(s => s.type === 'chart');

    for (const section of chartSections) {
      const sheet = {
        name: this.sanitizeSheetName(`Chart - ${section.title}`),
        charts: [
          {
            type: section.content.type,
            data: section.content.data,
            options: section.content.options,
            position: { from: 'A1', to: 'M20' },
          },
        ],
      };

      workbook.sheets.push(sheet);
    }
  }

  /**
   * 生データシートの作成
   */
  private createRawDataSheet(workbook: any, data: any): void {
    const sheet = {
      name: 'Raw Data',
      data: [],
    };

    // JSONデータを行列形式に変換
    const flattenedData = this.flattenObject(data);

    // ヘッダー
    sheet.data.push(['Key', 'Value']);

    // データ
    for (const [key, value] of Object.entries(flattenedData)) {
      sheet.data.push([key, String(value)]);
    }

    workbook.sheets.push(sheet);
  }

  /**
   * オブジェクトのフラット化
   */
  private flattenObject(obj: any, prefix: string = ''): Record<string, any> {
    const flattened: Record<string, any> = {};

    for (const [key, value] of Object.entries(obj)) {
      const newKey = prefix ? `${prefix}.${key}` : key;

      if (value === null || value === undefined) {
        flattened[newKey] = '';
      } else if (
        typeof value === 'object' &&
        !Array.isArray(value) &&
        !(value instanceof Date)
      ) {
        Object.assign(flattened, this.flattenObject(value, newKey));
      } else if (Array.isArray(value)) {
        flattened[newKey] = value.join(', ');
      } else {
        flattened[newKey] = value;
      }
    }

    return flattened;
  }

  /**
   * シート名のサニタイズ
   */
  private sanitizeSheetName(name: string): string {
    // Excelのシート名制限に対応
    return name
      .replace(/[\\/:*?\[\]]/g, '') // 禁止文字を削除
      .substring(0, 31); // 最大31文字
  }

  /**
   * 列番号を列文字に変換
   */
  private getColumnLetter(index: number): string {
    let letter = '';
    while (index >= 0) {
      letter = String.fromCharCode(65 + (index % 26)) + letter;
      index = Math.floor(index / 26) - 1;
    }
    return letter;
  }

  /**
   * 色をARGB形式に変換
   */
  private colorToARGB(hex: string): string {
    // #RRGGBBをFFRRGGBBに変換
    return 'FF' + hex.replace('#', '').toUpperCase();
  }
}
